\documentclass[bachelor, och, labwork]{shiza}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage{subfigure}
\usepackage{tikz,pgfplots}
\pgfplotsset{compat=1.5}
\usepackage{float}
\usepackage{pdfpages}

\usepackage{titlesec}
\setcounter{secnumdepth}{4}
\titleformat{\paragraph}
{\normalfont\normalsize}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{35.5pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\titleformat{\paragraph}[block]
{\hspace{1.25cm}\normalfont}
{\theparagraph}{1ex}{}
\titlespacing{\paragraph}
{0cm}{2ex plus 1ex minus .2ex}{.4ex plus.2ex}

% --------------------------------------------------------------------------%


\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage{tempora}

\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage{listingsutf8}
\usepackage{longtable}
\usepackage{array}
\usepackage[english,russian]{babel}

%\usepackage[colorlinks=true]{hyperref}
\usepackage{url}

\usepackage{underscore}
\usepackage{setspace}
\usepackage{indentfirst} 
\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{enumitem}
\usepackage{tikz}

\newcommand{\eqdef}{\stackrel {\rm def}{=}}
\newcommand{\specialcell}[2][c]{%
	\begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}

\renewcommand\theFancyVerbLine{\small\arabic{FancyVerbLine}}

\newtheorem{lem}{Лемма}

\begin{document}

	\includepdf{yahin-titulnik.pdf}
	
	%-------------------------------------------------------------------------------------------
	\tableofcontents
	
	\newpage
	
	Цель работы: изучение основных свойств бинарных отношений и операций замыкания бинарных отношений.
	
	\section{Бинарные отношения}
	    \subsection{Определение бинарного отношения}
	
	Подмножества декартова произведения $A \times B$ множеств $A$ и $B$ называются бинарными отношениями между элементами множеств $A, B$ и обозначаются строчными греческими буквами: 
	$\rho,\sigma, ..., \rho_1, \rho_2, ...   $.
	
	бинарными
	
	Для бинарного отношения $\rho \subset A \times B$ область определения $D_\rho$ и множество значений $E_\rho$ определяются как подмножества соответствующих множеств $А$ и $В$ по следующим формулам:
	
	 $D_\rho = \{a: (a,b) \in \rho $ для некоторого $ b \in B \}$,
	 
	 
	 $E_\rho = \{b: (a,b) \in \rho $ для некоторого $ a \in A \}$. 
	

    \subsection{Классификация бинарных отношений}

	Бинарное отношение $\rho \subset A \cdot A$ называется:

	\begin{enumerate}
		\item \textit{рефлексивным}, если $(a, a) \in \rho$ для любого $a \in A$;
		\item \textit{симметричным}, если $(a, b) \in \rho \Rightarrow (b, a) \in \rho$;
		\item \textit{антисимметричным}, если $(a, b) \in \rho \text{ и } (b, a) \in \rho \Rightarrow a = b$;
		\item \textit{транзитивным}, если $(a, b) \in \rho \text{ и } (b, c) \in \rho \Rightarrow (a, c) \in \rho$
	\end{enumerate}
	
	Основываясь на этом, можно выделить три типа отношений:
	
	\begin{enumerate}
		\item Отношение эквивалентности
		
		Бинарное отношение $\varepsilon $ на множестве $A$ называется 
		
		$\textit{отношением эквивалентности}$ (или просто $\textit{эквивалентностью}$),
		
		если оно рефлексивно, симметрично и транзитивно,
		\item Отношение квазипорядка
		
		Бинарное отношение $\omega $ на множестве $A$ называется 
		
		$\textit{отношением квазипорядка}$ (или просто $\textit{квазипорядком}$),
		
		 если оно рефлексивно и транзитивно,
		\item Отношение порядка
		
		Бинарное отношение $\omega $ на множестве $A$ называется 
		
		$\textit{отношением порядка}$ (или просто $\textit{порядком}$),
		
		 если оно рефлексивно, антисимметрично и транзитивно,
	\end{enumerate}
		
	Для того, чтобы реализовать алгоритм классификации бинарных отношений, удобно пользоваться матрицей бинарного отношения.
	
	$\textit{Матрицей}$ бинарного отношения $\rho$ между элементами множеств $A = \{a_1, ..., a_m\}$ и $B = \b_1, ..., b_n\}$ называется прямоугольная таблица $M(\rho)$, состоящая из $m$ строк и $n$ столбцов, в которой на пересечении i-ой строки и j-го столбца стоит элемент $[M(\rho)]_{ij}$ из множества {0,1}, определяемый по правилу:
	
	\begin{equation*}
		[M(\rho)]_{ij} =  
		\begin{cases}
			1 &\text{, если $(a_i, b_j) \in \rho$}\\
			0 &\text{, в противном случае}
		\end{cases}
	\end{equation*}


		\section{Системы замыканий}
	\subsection{Определение системы замыканий}
	
	Множество Z подмножеств множества A называется $\textit{системой замыканий}$, если оно замкнуто относительно пересечений, т.е. выполняется 
	
	$\cap B \in Z $ для любого подмножества $B \subset Z $
	
	
	\subsection{Лемма о системах замыканий бинарных отношений}
	  На множестве $P(A^2)$ всех бинарных отношений между элементами множества $A$ следующие множества являются системами замыканий:
	
	\begin{enumerate}
		\item $Z_r$ - множество всех рефлексивных бинарных отношений между элементами множества $A$,
		\item $Z_s$ – множество всех симметричных бинарных отношений между элементами множества $A$,
		\item $Z_t$ – множество всех транзитивных бинарных отношений между элементами множества $A$,
		\item $Z_{eq} = Eq(A)$ – множество всех отношений эквивалентности на множестве $A$.
	\end{enumerate}

	Множество $Z_{as}$ всех антисимметричных бинарных отношений между элементами множетсва $A$ не является системой замыкания.
	
	\section{Результаты работы}
	\subsection{Описание алгоритма классификации бинарных отношений}
	
	Из пункта 1.2 следует, что в нашем алгоритме будут определяться 5 свойств бинарных отношений, а именно:
	
	\begin{enumerate}
		\item рефлексивность,
		\item антирефлексивность,
		\item симметричность,
		\item антисимметричность,
		\item транзитивность.
	\end{enumerate}
	
		Как по матрице представления определить свойства бинарного отношения:
	\begin{enumerate}
		\item Для того, чтобы бинарное отношение было $\textit{рефлексивным}$, на главной  диагонали должны стоять только единицы,
		\item Для того, чтобы бинарное отношение было $\textit{антирефлексивным}$, на главной  диагонали должны стоять только нули,
		\item Для того, чтобы бинарное отношение было $\textit{симметричным}$, матрица представления должна равняться транспонированной матрице,
		\item Для того, чтобы бинарное отношение было $\textit{антисимметричным}$, в матрице должны отсутствовать единицы, симметричные относительно главной диагонали,
		\item Для того, чтобы бинарное отношение было $\textit{транзитивным}$, матрица, полученная перемножением матрицы саму на себя, должна являться частью исходной матрицы бинарного отношения.
	\end{enumerate}
	
	После проверки бинарного отношения на эти 5 свойств, мы можем судить,  к какому типу отношений относится данное бинарное отношение. В этом  и заключается алгоритм классификации.
	
	\begin{enumerate}
		\item Бинарное отношение является отношением эквивалентности, если выполнились следующие три свойства: рефлексивность, симметричность и транзитивность.
		\item Если выполнились свойства рефлексивности и транзитивности, то это отношение является отношением квазипорядка,
		\item Бинарное отношение является отношением порядка, если оно рефлексивно, антисимметрично и транзитивно.
	\end{enumerate}	
	
	\subsection{Описание алгоритма построения основных замыканий бинарных отношений}
	
	\begin{enumerate}
		\item Матрица $\textit{рефлексивного}$ замыкания равна $R \cup E_n$, т.е. необходимо все элементы главной диагонали заменить нулями,
		\item Матрица $\textit{симметричного}$ замыкания равна $R \cup R^T$, т.е. если элемент матрицы равен единице, то симметричный ему элемент относительно главной диагонали тоже должен быть равен единице,
		\item Стратегия построения матрицы $\textit{транзитивного}$ замыкания такова: если имеется две пары элементов (i, j) и (j, k), то необходимо добавить пару (i, k). После этого запустить цикл еще раз, т.к. после добавления новой пары этому условию могут удовлетворять еще две пары. 
		
	\end{enumerate}
	
	\subsection{Код программы}	

	
	 \begin{verbatim}
		#include <iostream>
		
		using namespace std;
		int brk = 0;
		
		bool bo_is_reflexive(int N, int **a)
		{
			int res = 0;
			
			for (int i = 0; i < N; ++i)
			{
				if (a[i][i] == 1)
				res = 1;
				else res = 0;
				
				if (res == 0)
				{
					return  res;
				}
			}
			
			return  res;
		}
		
		bool bo_is_antireflexive(int N, int **a)
		{
			int res = 0;
			
			for (int i = 0; i < N; ++i)
			{
				if (a[i][i] == 0)
				res = 1;
				else res = 0;
				
				if (res == 0)
				{
					return  res;
				}
			}
			
			return  res;
		}
		
		bool bo_is_symmetric(int N, int **a)
		{
			int res = 0;
			
			for (int i = 0; i < N; ++i)
			{
				for (int j = i + 1; j < N; ++j)
				{
					if (a[i][j] == a[j][i])
					res = 1;
					else res = 0;
					
					if (res == 0)
					{
						return  res;
					}
				}
			}
			
			return  res;
		}
		
		bool bo_is_antisymmetric(int N, int** a)
		{
			int res = 0;
			
			for (int i = 0; i < N; ++i)
			{
				for (int j = i + 1; j < N; ++j)
				{
					if (a[i][j] == 1 && a[j][i] == 1) {
						if (i = j)
						res = 1;
						else res = 0;
					}
					else res = 0;
					
					if (res == 0)
					{
						return  res;
					}
				}
			}
			
			return  res;
		}
		
		bool bo_is_transitive(int N, int** a)
		{
			int res = 0;
			
			for (int i = 0; i < N; ++i)
			{
				for (int j = 0; j < N; ++j)
				{
					for (int k = 0; k < N; ++k)
					{
						if (a[i][j] >= a[i][k] * a[k][j])
						res = 1;
						else res = 0;
						
						if (res == 0)
						{
							return  res;
						}
					}
				}
			}
			
			return  res;
		}
		
		//строим замыкания
		void z_reflexive(int N, int** a)
		{
			for (int i = 0; i < N; i++)
			{
				a[i][i] = 1;
			}
		}
		
		void z_sim(int N, int** a)
		{
			for (int i = 0; i < N; i++)
			{
				for (int j = 0; j < N; j++)
				{
					if (a[i][j] == 1)
					a[j][i] = 1;
				}
			}
		}
		
		void z_tranz(int N, int** a)
		{
			for (int i = 0; i < N; i++) 
			for (int j = 0; j < N; j++) 
			for (int k = 0; k < N; k++) 
			if (a[j][k] == 1) 
			for (int d = 0; d < N; d++) 
			if (a[k][d] == 1)
			a[j][d] = 1;
			
		}
		
		
		void z_build(int N, int** a, int vvod)
		{
			int** z_a;
			z_a = new int* [N];
			for (int i = 0; i < N; i++) {
				z_a[i] = new int[N];
				for (int j = 0; j < N; j++) {
					z_a[i][j] = a[i][j];
				}
			}
			switch (vvod)
			{
				case 1:
				z_reflexive(N, z_a);
				break;
				case 2:
				z_sim(N, z_a);
				break;
				case 3:
				z_tranz(N, z_a);
				break;
				case 4:
				z_reflexive(N, z_a);
				z_sim(N, z_a);
				z_tranz(N, z_a);
				break;
				case 5:
				brk = 1;
				break;
				default:
				cout << "Error" << endl;
				break;
			}
			if (brk == 0) {
				cout << "Построенное замыкание:" << endl;
				for (int i = 0; i < N; i++) {
					for (int j = 0; j < N; j++)
					cout << z_a[i][j] << ' ';
					cout << endl;
				}
			}
		}
		
		void    bo_result(int N, int **a)
		{
			cout << "Введеная матрица:" << endl;
			for (int i = 0; i < N; i++) {
				for (int j = 0; j < N; j++)
				cout << a[i][j] << ' ';
				cout << endl;
			}
			int res_refl = bo_is_reflexive(N, a);
			int res_antirefl = bo_is_antireflexive(N, a);
			int res_simm = bo_is_symmetric(N, a);
			int res_antisimm = bo_is_antisymmetric(N, a);
			int res_tranz = bo_is_transitive(N, a);
			cout << "Результаты (1 - да, 0 - нет):" << endl;
			cout << "Рефлексивность:" << res_refl << endl;
			cout << "Антирефлексивность:" << res_antirefl << endl;
			cout << "Симметричность:" << res_simm << endl;
			cout << "Антисимметричность:" << res_antisimm << endl;
			cout << "Транзитивность:" << res_tranz << endl;
			
			if (res_refl == 1 && res_antirefl == 0 && 
			res_antisimm == 0 && res_tranz == 1) {
				cout << "Данное отношение является отношением квазипорядка" << endl;
				if (res_simm == 1)
				cout << "Данное отношение является отношением эквивалентности" << endl;
			}
			if (res_refl == 1 && res_antirefl == 0 && res_simm == 0 && 
			res_antisimm == 1 && res_tranz == 1) {
				cout << "Данное отношение является отношением порядка" << endl;
			}
			
			int vvod;
			cout << "Введите, какое замыкание требуется построить:" << endl;
			cout << "1 - рефлексивное" << endl << "2 - симметричное" << endl << 
			"3 - транзитивное" << endl << "4 - эквивалентное" << endl << 
			"5 - не строить никакое замыкание" << endl;
			while (brk == 0) {
				cout << "Введите номер:" << endl;
				cin >> vvod;
				z_build(N, a, vvod);
			}
		}
		int main()
		{
			setlocale(LC_ALL, "Rus");
			
			int sposob, i, j, N;
			cout << "Введите способ ввода (1 - поэлементно, 2 - построчно): "; 
			cin >> sposob;
			cout << "Введите размерность матрицы бинарного отношения: "; 
			cin >> N;
			int ** a;
			a = new int* [N];
			cout << "Введите матрицу А" << endl;
			if (sposob == 1) {
				for (i = 0; i < N; i++) {
					a[i] = new int[N];
					for (j = 0; j < N; j++) {
						cout << "A["
						<< i
						<< "]["
						<< j
						<< "] = ";
						cin >> a[i][j];
					}
				}
			}
			else
			{
				for (int i = 0; i < N; i++) {
					a[i] = new int[N];
					for (int j = 0; j < N; j++) {
						cin >> a[i][j];
					}
				}
			}
			
			cout << endl;
			bo_result(N, a);
			cout << endl;
		}
		
	\end{verbatim}
	
	\subsection{Результаты тестирования программ}
	
	Тестирование №1:
	
	На вход поступает матрица:
	
	\begin{pmatrix}
		1 & 1 & 1 & 0 & 0 \\
		1 & 1 & 1 & 1 & 1 \\
		1 & 1 & 1 & 0 & 0 \\
		0 & 1 & 0 & 0 & 0 \\
		0 & 1 & 0 & 0 & 0 
	\end{pmatrix}

Она обладает свойством симметричности.

Построим рефлексивное замыкание.

	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\textwidth]{test1}
		\caption{Тестировние №1}
		\label{fig:test1}
	\end{figure}
	
	Тестирование №2:
	
	На вход поступает матрица:
	
	\begin{pmatrix}
		0 & 0 & 0 & 0 & 0 \\
		1 & 0 & 0 & 0 & 0 \\
		1 & 1 & 0 & 0 & 0 \\
		1 & 1 & 0 & 0 & 0 \\
		1 & 1 & 1 & 0 & 0 
	\end{pmatrix}
	
	Она обладает свойством антирефлексивности и транзитивности.
	
	Построим все типы замыканий.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\textwidth]{test2}
		\caption{Тестировние №2}
		\label{fig:test2}
	\end{figure}
	
	Тестирование №3:

	На вход поступает матрица:
	
	\begin{pmatrix}
		1 & 0 & 0 & 0 & 1 \\
		0 & 1 & 1 & 1 & 0 \\
		0 & 1 & 1 & 1 & 0 \\
		0 & 1 & 1 & 1 & 0 \\
		1 & 0 & 0 & 0 & 1 
	\end{pmatrix}
	
	Она обладает свойством рефлексивности, симметричности и транзитивности, а значит является отношением квазипорядка и отношением эквивалентности.

	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\textwidth]{test3}
		\caption{Тестировние №3}
		\label{fig:test3}
	\end{figure}

	\subsection{Оценки сложности рассмотренных алгоритмов }
	
	\begin{enumerate}
		\item Определение рефлексивности
		
		Временная сложность алгоритма определения рефлексивности = $O(n)$
		\item Определение антирефлексивности

		Временная сложность алгоритма определения антирефлексивности = $O(n)$
		\item Определение симметричности

		Временная сложность алгоритма определения симметричности = $O(n^2/2)$ = $O(n^2)$
		\item Определение антисимметричности

		Временная сложность алгоритма определения антисимметричности = $O(n^2/2)$ = $O(n^2)$
		\item Определение транзитивности

		Временная сложность алгоритма определения транзитивности = $O(n^3)$
		
		\item Определение отношения эквивалентности
		
		Временная сложность алгоритма определения отношения эквивалентности = $O(n^3 + n^2/2 + n)$ = $O(n^3)$
		
		\item Определение отношения квазипорядка

		Временная сложность алгоритма определения отношения эквивалентности = $O(n^3 + n^2/2 + n)$ = $O(n^3)$
		
		\item Определение отношения порядка
		
		Временная сложность алгоритма определения отношения эквивалентности = $O(n^3 + n)$ = $O(n^3)$
		
		\item Определение построения замыкания рефлексивности
		
		Временная сложность алгоритма определения построения замыкания рефлексивности = $O(n)$
		
		\item Определение построения замыкания симметричности
		
		Временная сложность алгоритма определения построения замыкания симметричности = $O(n^2)$
		
		\item Определение построения замыкания транзитивности

		Временная сложность алгоритма определения построения замыкания транзитивности = $O(n^4)$

		\item Определение построения замыкания эквивалентности

		Временная сложность алгоритма определения построения замыкания эквивалентности = $O(n^4 + n^2 + n)$ = $O(n^4)$
	\end{enumerate}
	
	\newpage
	\conclusion %заключение
	
	В данной лабораторной работе были рассмотрены и изучены следующие темы: основные определения видов бинарных отношений, свойства бинарных отношений и основные системы замыкания на множестве бинарных отношений. В третьей части работы были реализованы алгоритмы классификации бинарных отношений и построения основных замыканий бинарных отношений.
	
	
\end{document}